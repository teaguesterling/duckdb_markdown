# name: test/sql/markdown_sections_features.test
# description: Test section extraction features including backticks, section_path, frontmatter, and metadata
# group: [sql]

require markdown

# =============================================================================
# Test: Headings with backticks (inline code) - Issue #7
# =============================================================================

# Test that backticks in headings are properly extracted
query TTI
SELECT section.section_id, section.title, section.level
FROM (SELECT UNNEST(md_extract_sections(E'# API Reference\n## Functions\n### `read_data(path)`\nReads data from path.\n### `write_data(path, data)`\nWrites data to path.')) as section)
ORDER BY section.start_line;
----
api-reference	API Reference	1
functions	Functions	2
read_data-path	read_data(path)	3
write_data-path-data	write_data(path, data)	3

# Test complex backtick headings with parameters
query TT
SELECT section.section_id, section.title
FROM (SELECT UNNEST(md_extract_sections(E'# Docs\n## `parse_ast(source_code, language, [options...])`\nParses AST.')) as section)
WHERE section.level = 2;
----
parse_ast-source_code-language-options	parse_ast(source_code, language, [options...])

# Test mixed formatting in headings (bold, italic, code)
query TT
SELECT section.section_id, section.title
FROM (SELECT UNNEST(md_extract_sections(E'# Main\n## **Bold** and `code` heading\n## _Italic_ heading')) as section)
WHERE section.level = 2
ORDER BY section.start_line;
----
bold-and-code-heading	Bold and code heading
italic-heading	Italic heading

# =============================================================================
# Test: section_path column for hierarchical navigation (using test file)
# =============================================================================

# Test section_path builds correct hierarchy from file
query TTT
SELECT section_id, section_path, title
FROM read_markdown_sections('test/markdown/sections_test.md', extract_metadata := false)
WHERE level <= 3
ORDER BY start_line
LIMIT 7;
----
api-reference	api-reference	API Reference
functions	api-reference/functions	Functions
read_data-path	api-reference/functions/read_data-path	read_data(path)
write_data-path-data	api-reference/functions/write_data-path-data	write_data(path, data)
classes	api-reference/classes	Classes
datamanager	api-reference/classes/datamanager	DataManager
bold-and-code-heading	api-reference/bold-and-code-heading	Bold and code heading

# Test section_path with scalar function
query TT
SELECT section.section_id, section.section_path
FROM (SELECT UNNEST(md_extract_sections(E'# L1\n## L2\n### L3\n#### L4')) as section)
ORDER BY section.start_line;
----
l1	l1
l2	l1/l2
l3	l1/l2/l3
l4	l1/l2/l3/l4

# Test section_path resets when going back up levels
query TT
SELECT section.section_id, section.section_path
FROM (SELECT UNNEST(md_extract_sections(E'# Doc\n## Part 1\n### Ch 1\n## Part 2\n### Ch 2')) as section)
ORDER BY section.start_line;
----
doc	doc
part-1	doc/part-1
ch-1	doc/part-1/ch-1
part-2	doc/part-2
ch-2	doc/part-2/ch-2

# =============================================================================
# Test: Frontmatter handling in sections
# =============================================================================

# Test frontmatter is not parsed as heading (Issue #5)
query TTI
SELECT section.section_id, section.title, section.level
FROM (SELECT UNNEST(md_extract_sections(E'---\ntitle: My Doc\nauthor: Test\n---\n\n# Real Heading\nContent here.')) as section)
ORDER BY section.start_line;
----
real-heading	Real Heading	1

# Test frontmatter section from file with extract_metadata=true
query TTI
SELECT section_id, title, level
FROM read_markdown_sections('test/markdown/metadata.md', extract_metadata := true)
ORDER BY start_line;
----
frontmatter	frontmatter	0
test-document	Test Document	1

# Test frontmatter section contains raw YAML content
query T
SELECT content LIKE '%title: Test Document%' AND content LIKE '%author: John Doe%' as has_yaml
FROM read_markdown_sections('test/markdown/metadata.md', extract_metadata := true)
WHERE section_id = 'frontmatter';
----
true

# =============================================================================
# Test: Metadata extraction as MAP
# =============================================================================

# Test md_extract_metadata returns MAP type
query T
SELECT typeof(md_extract_metadata(E'---\ntitle: Test\n---\nContent'::markdown));
----
MAP(VARCHAR, VARCHAR)

# Test extracting specific metadata fields
query TT
SELECT md_extract_metadata(E'---\ntitle: My Title\nauthor: John Doe\ndate: 2024-01-15\n---\nContent'::markdown)['title'] as title,
       md_extract_metadata(E'---\ntitle: My Title\nauthor: John Doe\ndate: 2024-01-15\n---\nContent'::markdown)['author'] as author;
----
My Title	John Doe

# Test custom/arbitrary metadata fields are included
query T
SELECT md_extract_metadata(E'---\ntitle: Test\ncustom_field: custom_value\nanother: value2\n---\nContent'::markdown)['custom_field'];
----
custom_value

# Test empty metadata returns empty map
query I
SELECT cardinality(md_extract_metadata(E'# No frontmatter\nJust content'::markdown));
----
0

# Test read_markdown metadata column is MAP type
query T
SELECT typeof(metadata) FROM read_markdown('test/markdown/metadata.md', extract_metadata := true);
----
MAP(VARCHAR, VARCHAR)

# Test metadata map access from file
query T
SELECT metadata['title'] FROM read_markdown('test/markdown/metadata.md', extract_metadata := true);
----
Test Document

# =============================================================================
# Test: Edge cases for section_path hierarchy
# =============================================================================

# Test deep nesting (6 levels)
query TT
SELECT section.section_id, section.section_path
FROM (SELECT UNNEST(md_extract_sections(E'# L1\n## L2\n### L3\n#### L4\n##### L5\n###### L6')) as section)
ORDER BY section.start_line;
----
l1	l1
l2	l1/l2
l3	l1/l2/l3
l4	l1/l2/l3/l4
l5	l1/l2/l3/l4/l5
l6	l1/l2/l3/l4/l5/l6

# Test skipping levels (h1 -> h3 directly)
query TT
SELECT section.section_id, section.section_path
FROM (SELECT UNNEST(md_extract_sections(E'# Top\n### Skipped to L3\n## Back to L2')) as section)
ORDER BY section.start_line;
----
top	top
skipped-to-l3	top/skipped-to-l3
back-to-l2	top/back-to-l2

# Test multiple top-level headings
query TT
SELECT section.section_id, section.section_path
FROM (SELECT UNNEST(md_extract_sections(E'# First\n## Child1\n# Second\n## Child2')) as section)
ORDER BY section.start_line;
----
first	first
child1	first/child1
second	second
child2	second/child2

# Test duplicate heading IDs get numbered suffixes
query TT
SELECT section.section_id, section.section_path
FROM (SELECT UNNEST(md_extract_sections(E'# Intro\n## Overview\n# Intro\n## Overview')) as section)
ORDER BY section.start_line;
----
intro	intro
overview	intro/overview
intro-1	intro-1
overview-1	intro-1/overview-1

# =============================================================================
# Test: More backtick/inline code edge cases
# =============================================================================

# Test multiple backtick segments in one heading
query TT
SELECT section.section_id, section.title
FROM (SELECT UNNEST(md_extract_sections(E'# API\n## `foo()` and `bar()` functions')) as section)
WHERE section.level = 2;
----
foo-and-bar-functions	foo() and bar() functions

# Test code with special characters
query TT
SELECT section.section_id, section.title
FROM (SELECT UNNEST(md_extract_sections(E'# API\n## `array[0]->field`')) as section)
WHERE section.level = 2;
----
array-0-field	array[0]->field

# Test nested formatting (bold inside code won't work, but code inside bold)
query TT
SELECT section.section_id, section.title
FROM (SELECT UNNEST(md_extract_sections(E'# Doc\n## **Important**: `config.yaml`')) as section)
WHERE section.level = 2;
----
important-config-yaml	Important: config.yaml

# Test heading with only backticks
query TT
SELECT section.section_id, section.title
FROM (SELECT UNNEST(md_extract_sections(E'# API\n## `main()`')) as section)
WHERE section.level = 2;
----
main	main()

# =============================================================================
# Test: Frontmatter edge cases
# =============================================================================

# Test frontmatter with special characters in values
query T
SELECT md_extract_metadata(E'---\ntitle: Hello: World\nurl: https://example.com\n---\nContent'::markdown)['url'];
----
https://example.com

# Test frontmatter with quoted values
query T
SELECT md_extract_metadata(E'---\ntitle: "Quoted Value"\n---\nContent'::markdown)['title'];
----
Quoted Value

# Test document with horizontal rules in body (--- not at start is NOT frontmatter)
# This verifies that --- in document body is treated as horizontal rule, not frontmatter
query I
SELECT count(*)
FROM (SELECT UNNEST(md_extract_sections(E'# Doc\nSome text\n\n---\n\n## Section Two\nThis is not frontmatter\n\n---\n\n## Section Three\nMore text')) as section);
----
3

# Test empty document produces no sections
query I
SELECT count(*)
FROM (SELECT UNNEST(md_extract_sections(E'')) as section);
----
0

# Test document with only frontmatter (no headings)
query I
SELECT count(*)
FROM (SELECT UNNEST(md_extract_sections(E'---\ntitle: Test\n---\nJust content, no headings.')) as section);
----
0

# =============================================================================
# Test: Metadata extraction edge cases
# =============================================================================

# Test metadata with colons in value
query T
SELECT md_extract_metadata(E'---\nmessage: Error: file not found\n---\nContent'::markdown)['message'];
----
Error: file not found

# Test multiple metadata fields
query I
SELECT cardinality(md_extract_metadata(E'---\na: 1\nb: 2\nc: 3\nd: 4\ne: 5\n---\nContent'::markdown));
----
5

# Test metadata keys are preserved as-is
query T
SELECT md_extract_metadata(E'---\nCamelCase: value\n---\nContent'::markdown)['CamelCase'];
----
value

# =============================================================================
# Test: Scalar function md_extract_sections completeness
# =============================================================================

# Test all fields are present in scalar function output
query TTITTTII
SELECT section.section_id, section.section_path, section.level, section.title,
       section.parent_id, typeof(section.content), section.start_line, section.end_line
FROM (SELECT UNNEST(md_extract_sections(E'# Parent\n## Child\nContent here')) as section)
ORDER BY section.start_line;
----
parent	parent	1	Parent	NULL	md	1	1
child	parent/child	2	Child	parent	md	2	2

# Test content is captured correctly
query T
SELECT section.content LIKE '%Content here%'
FROM (SELECT UNNEST(md_extract_sections(E'# Parent\n## Child\nContent here')) as section)
WHERE section.section_id = 'child';
----
true

# =============================================================================
# Test: Section content extraction
# =============================================================================

# Test section content includes text but not subsection headings
query T
SELECT length(section.content) > 0
FROM (SELECT UNNEST(md_extract_sections(E'# Main\nIntro text\n## Sub\nSub content')) as section)
WHERE section.section_id = 'main';
----
true

# Test last section captures remaining content
query T
SELECT section.content LIKE '%Final content%'
FROM (SELECT UNNEST(md_extract_sections(E'# First\n## Last\nFinal content here.')) as section)
WHERE section.section_id = 'last';
----
true
